MODULO 1

Podemos automatizar o processo de compilação que será disparado toda vez que um arquivo .ts for modificado. Para isso, vamos adicionar mais um script em alurabank/package.json, o script 
"start": "tsc -w":
para rodar:
npm start

Nesse capítulo, vimos:

Modelagem da classe Negociacao utilizando a sintaxe private.
Instalação e configuração do compilador TypeScript
A diferença entre o código que escrevemos e o código compilado
O modificador de acesso private
Compilação em tempo real dos arquivos .ts
=========================
MODULO 2

O TypeScript infere o tipo, sendo assim, a sintaxe é a mesma coisa que:

let nome: string = 'Flávio';
let idade: number = 20;
Se fizermos typeof nas duas variáveis temos como resultado string e number respectivamente:

let nome: string = 'Flávio';
console.log(typeof(nome));  // string
let idade: number = 20; 
console.log(typeof(idade));// number

Neste capítulo, vimos:

O tipo implícito any
Utilização de tipos explícitos
Conversão explícita de tipos através de casting
Benefícios de utilizarmos os tipo específicos
=========================
MODULO 3

Vimos neste capítulo:

Criando de um novo modelo para encapsular uma lista de objetos do tipo Negociacao.
Array e generics
Manipulação declarativa do DOM através de template
Template dinâmico
=========================
MODULO 4

Vimos neste capítulo:

Reuso de código através de herança
Generics
Classes abstratas
=========================
MODULO 5

jQuery foi criado com TypeScript? Com certeza não e, se não foi, não possui variáveis, propriedades e parâmetro de métodos e funções tipados. Então, como suportar os recursos da linguagem TypeScript com uma biblioteca que não foi criada utilizando nessa linguagem?

Os criadores da biblioteca ou terceiros podem criar um arquivo chamado TypeScript Declaration File. Este arquivo possui informações dos nomes de métodos e funções, inclusive tipos que podem ser utilizados pelo TypeScript. Quando carregado, o TypeScript conseguirá, baseado nesse arquivo, realizar checagem estática inclusive lançar mão de todos seu poder através de seu editor ou IDE favorita.

No caso, vamos instalar o tipo do jQuery. Vale lembrar que esse tipo não foi definido pela equipe do jQuery:

npm install @types/jquery@2.0.42 --save-dev

*Para saber mais: o repositório @types
No npm, existe uma série de TypeScript definitons files para as mais diversas bibliotecas e frameworks do mercado. Por exemplo, se quisermos instalar o tds do jQuery, acessamos

https://www.npmjs.com/package/@types/jquery

Se quisermos do lodash ou underscore acessamos

https://www.npmjs.com/package/@types/lodash

https://www.npmjs.com/package/@types/underscore
Dessa forma, antes de sair buscando pela internet os arquivos tsd que precisamos, podemos tentar a sorte executando o comando:

npm install @types/nomeDaLibOuFramework --save-dev
Nesse sentido, se quisermos instalar os tds das três bibliotecas que foram citadas, fazemos:

npm install @types/jquery --save-dev
npm install @types/loadash --save-dev
npm install @types/underscore --save-dev
Qualquer tds files que esteja dentro de node_modules/@types será lidado automaticamente pelo compilador do TypeScript.

É preciso se conformar quando não houver do Typing para sua biblioteca preferia, neste caso, a estratégia do declare var que vimos neste treinamento é uma saída, não muito ideal, mas que permitirá seu código compilar até que você encontre seu tsd.

Não é raro o desenvolvedor querer comentar seu código, seja no estilo livro ou usando uma forma padronizada. No entanto, não faz sentido esses comentários irem para o arquivo de produção, pois além de deixarem evidente para terceiros o que o código que escrevemos faz, ainda acaba impactando no tamanho final do arquivo.

Podemos resolver esse problema facilmente solicitando ao compilador do TypeScript que remova todos os comentários do arquivo JavaScript resultante da compilação do nosso código TypeScript. Para isso, basta adicionar a propriedade "removeComments": true no arquivo tsconfig.json.

Vimos neste capítulo:

O problema de usarmos bibliotecas que ficam no escopo global e que não foram criados com TypeScript
"Calar a boca" do compilador com declare var.
As desvantagens de declare var com o tipo any.
O papel do TypeScript Definition.
Instalação de arquivos td.s de terceiros
Remoção de comentário durante a compilação
=========================
----
# # PARTE 2
----

=========================
MODULO 1
Hoje a definição das nossas classes vivem no escopo global. Além disso, para que o desenvolvedor saiba quais são as classes disponíveis pelo autocomplete do TypeScript ele precisa saber pelo menos parte do nome. Contudo, TypeScript oferece o conceito de namespace. Podemos agrupar classes dentro de um mesmo namepace e acessá-las através dele.

No caso, vamos envolver todas as classes dentro de alurabank/app/views no namespace Views:

namespace Views {

    export abstract class View<T> {

        protected _elemento: JQuery;

        constructor(seletor: string) {

            this._elemento = $(seletor);
        }

        update(model: T) {

            this._elemento.html(this.template(model));
        }

        abstract template(model: T): string;

    }

}

A sintaxe de módulos do ES2015 considera cada script um módulo e através das instruções import e export importamos e exportamos artefatos respectivamente.
Adequando todos os arquivos para o sistema de módulos do ES2015:
import { View } from './View';
import { Negociacoes } from '../models/Negociacoes';

export class NegociacoesView extends View<Negociacoes> {
    ...
}

LITE-SERVER
Como vimos, precisamos servir nossa aplicação através de um servidor web. Utilizaremos o lite-server. Além dele servir a pasta alurabanl/app para nós, ele ainda suporta livereloading através do BrowserSync que traz embutido. Isso é perfeito, pois toda vez que os arquivos .ts forem modificados e os arquivos .js gerados nosso navegador automaticamente será recarregado.

Rodando scripts paralelamente com o módulo concurrently
Vamos instalar o módulo concurrently. Ele nos permitirá rodar os dois scripts que criamos em paralelo nas plataformas Windows, MAC e Linux.

Agora, vamos renomear o script "start" para "watch" e adicionar novamente o script "start" que chamará o módulo concurrently:

{
  "name": "alurabank",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "compile": "tsc",
    "watch": "tsc -w",
    "server": "lite-server --baseDir=app",
    "start": "concurrently \"npm run watch\" \"npm run server\""
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/jquery": "^2.0.42",
    "concurrently": "^3.4.0",
    "lite-server": "^2.3.0",
    "typescript": "^2.3.2"
  }
}
Excelente, agora, no terminal, basta executarmos o comando npm start para termos os dois serviços rodando em paralelo em um único terminal.

npm start

Podemos simplificar bastante a importação dos módulos através da estratégia Barrel (barril). Nela, um módulo importa e exporta todos os artefatos de uma pasta permitindo assim que apenas o barril seja importado na cláusula from.

Vejamos:

// app/ts/views/index.ts

export * from './View'; 
export * from './MensagemView'; 
export * from './NegociacoesView';
// app/ts/models/index.ts

export * from './Negociacao'; 
export * from './Negociacoes';

O loader utilizado nos obriga a escrever index no final da importação do módulo. Projetos em Angular e Ionic que fazem uso do Webpack podem omiti-lo na importação. O importante é sabermos desta forma prática de organizar nossos módulos.

Aprendemos neste capítulo:

A utilizar namespaces
Sistemas de módulos do ES2015
O papel de um loader
Levantar um servidor local
Organização de módulo em barris
=========================
MODULO 2

Nossa classe Negociacao possui atributos privados, pois não faz sentido alterarmos uma instância de Negociacao depois de criada. Vamos recapitular:

export class Negociacao {

    constructor(private _data: Date, private _quantidade: number, private _valor: number) {}

    get data() {

        return this._data;
    }

    get quantidade() {

        return this._quantidade;
    }

    get valor() {

        return this._valor;
    }

    get volume() {

        return this._quantidade * this._valor;
    }
}

Contudo, o TypeScript possui um atalho para declaração de propriedades somente leitura. Para isso, basta usarmos o modificador readonly.

export class Negociacao {

    constructor(readonly data: Date, readonly quantidade: number, readonly valor: number) {}

    get volume() {

        return this.quantidade * this.valor;
    }
}
Veja que não foi necessário criar os getters para que pudéssemos acessar as propriedades que antes eram privadas. Agora, qualquer atribuição feita às propriedades resultarão em erro de compilação.