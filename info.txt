MODULO 1

Podemos automatizar o processo de compilação que será disparado toda vez que um arquivo .ts for modificado. Para isso, vamos adicionar mais um script em alurabank/package.json, o script 
"start": "tsc -w":
para rodar:
npm start

Nesse capítulo, vimos:

Modelagem da classe Negociacao utilizando a sintaxe private.
Instalação e configuração do compilador TypeScript
A diferença entre o código que escrevemos e o código compilado
O modificador de acesso private
Compilação em tempo real dos arquivos .ts
=========================
MODULO 2

O TypeScript infere o tipo, sendo assim, a sintaxe é a mesma coisa que:

let nome: string = 'Flávio';
let idade: number = 20;
Se fizermos typeof nas duas variáveis temos como resultado string e number respectivamente:

let nome: string = 'Flávio';
console.log(typeof(nome));  // string
let idade: number = 20; 
console.log(typeof(idade));// number

Neste capítulo, vimos:

O tipo implícito any
Utilização de tipos explícitos
Conversão explícita de tipos através de casting
Benefícios de utilizarmos os tipo específicos
=========================
MODULO 3

Vimos neste capítulo:

Criando de um novo modelo para encapsular uma lista de objetos do tipo Negociacao.
Array e generics
Manipulação declarativa do DOM através de template
Template dinâmico
=========================
MODULO 4

Vimos neste capítulo:

Reuso de código através de herança
Generics
Classes abstratas
=========================
MODULO 5

jQuery foi criado com TypeScript? Com certeza não e, se não foi, não possui variáveis, propriedades e parâmetro de métodos e funções tipados. Então, como suportar os recursos da linguagem TypeScript com uma biblioteca que não foi criada utilizando nessa linguagem?

Os criadores da biblioteca ou terceiros podem criar um arquivo chamado TypeScript Declaration File. Este arquivo possui informações dos nomes de métodos e funções, inclusive tipos que podem ser utilizados pelo TypeScript. Quando carregado, o TypeScript conseguirá, baseado nesse arquivo, realizar checagem estática inclusive lançar mão de todos seu poder através de seu editor ou IDE favorita.

No caso, vamos instalar o tipo do jQuery. Vale lembrar que esse tipo não foi definido pela equipe do jQuery:

npm install @types/jquery@2.0.42 --save-dev

*Para saber mais: o repositório @types
No npm, existe uma série de TypeScript definitons files para as mais diversas bibliotecas e frameworks do mercado. Por exemplo, se quisermos instalar o tds do jQuery, acessamos

https://www.npmjs.com/package/@types/jquery

Se quisermos do lodash ou underscore acessamos

https://www.npmjs.com/package/@types/lodash

https://www.npmjs.com/package/@types/underscore
Dessa forma, antes de sair buscando pela internet os arquivos tsd que precisamos, podemos tentar a sorte executando o comando:

npm install @types/nomeDaLibOuFramework --save-dev
Nesse sentido, se quisermos instalar os tds das três bibliotecas que foram citadas, fazemos:

npm install @types/jquery --save-dev
npm install @types/loadash --save-dev
npm install @types/underscore --save-dev
Qualquer tds files que esteja dentro de node_modules/@types será lidado automaticamente pelo compilador do TypeScript.

É preciso se conformar quando não houver do Typing para sua biblioteca preferia, neste caso, a estratégia do declare var que vimos neste treinamento é uma saída, não muito ideal, mas que permitirá seu código compilar até que você encontre seu tsd.

Não é raro o desenvolvedor querer comentar seu código, seja no estilo livro ou usando uma forma padronizada. No entanto, não faz sentido esses comentários irem para o arquivo de produção, pois além de deixarem evidente para terceiros o que o código que escrevemos faz, ainda acaba impactando no tamanho final do arquivo.

Podemos resolver esse problema facilmente solicitando ao compilador do TypeScript que remova todos os comentários do arquivo JavaScript resultante da compilação do nosso código TypeScript. Para isso, basta adicionar a propriedade "removeComments": true no arquivo tsconfig.json.

Vimos neste capítulo:

O problema de usarmos bibliotecas que ficam no escopo global e que não foram criados com TypeScript
"Calar a boca" do compilador com declare var.
As desvantagens de declare var com o tipo any.
O papel do TypeScript Definition.
Instalação de arquivos td.s de terceiros
Remoção de comentário durante a compilação
=========================
----
# # PARTE 2
----

=========================
MODULO 1
Hoje a definição das nossas classes vivem no escopo global. Além disso, para que o desenvolvedor saiba quais são as classes disponíveis pelo autocomplete do TypeScript ele precisa saber pelo menos parte do nome. Contudo, TypeScript oferece o conceito de namespace. Podemos agrupar classes dentro de um mesmo namepace e acessá-las através dele.

No caso, vamos envolver todas as classes dentro de alurabank/app/views no namespace Views:

namespace Views {

    export abstract class View<T> {

        protected _elemento: JQuery;

        constructor(seletor: string) {

            this._elemento = $(seletor);
        }

        update(model: T) {

            this._elemento.html(this.template(model));
        }

        abstract template(model: T): string;

    }

}

A sintaxe de módulos do ES2015 considera cada script um módulo e através das instruções import e export importamos e exportamos artefatos respectivamente.
Adequando todos os arquivos para o sistema de módulos do ES2015:
import { View } from './View';
import { Negociacoes } from '../models/Negociacoes';

export class NegociacoesView extends View<Negociacoes> {
    ...
}

LITE-SERVER
Como vimos, precisamos servir nossa aplicação através de um servidor web. Utilizaremos o lite-server. Além dele servir a pasta alurabanl/app para nós, ele ainda suporta livereloading através do BrowserSync que traz embutido. Isso é perfeito, pois toda vez que os arquivos .ts forem modificados e os arquivos .js gerados nosso navegador automaticamente será recarregado.

Rodando scripts paralelamente com o módulo concurrently
Vamos instalar o módulo concurrently. Ele nos permitirá rodar os dois scripts que criamos em paralelo nas plataformas Windows, MAC e Linux.

Agora, vamos renomear o script "start" para "watch" e adicionar novamente o script "start" que chamará o módulo concurrently:

{
  "name": "alurabank",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "compile": "tsc",
    "watch": "tsc -w",
    "server": "lite-server --baseDir=app",
    "start": "concurrently \"npm run watch\" \"npm run server\""
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/jquery": "^2.0.42",
    "concurrently": "^3.4.0",
    "lite-server": "^2.3.0",
    "typescript": "^2.3.2"
  }
}
Excelente, agora, no terminal, basta executarmos o comando npm start para termos os dois serviços rodando em paralelo em um único terminal.

npm start

Podemos simplificar bastante a importação dos módulos através da estratégia Barrel (barril). Nela, um módulo importa e exporta todos os artefatos de uma pasta permitindo assim que apenas o barril seja importado na cláusula from.

Vejamos:

// app/ts/views/index.ts

export * from './View'; 
export * from './MensagemView'; 
export * from './NegociacoesView';
// app/ts/models/index.ts

export * from './Negociacao'; 
export * from './Negociacoes';

O loader utilizado nos obriga a escrever index no final da importação do módulo. Projetos em Angular e Ionic que fazem uso do Webpack podem omiti-lo na importação. O importante é sabermos desta forma prática de organizar nossos módulos.

Aprendemos neste capítulo:

A utilizar namespaces
Sistemas de módulos do ES2015
O papel de um loader
Levantar um servidor local
Organização de módulo em barris
=========================
MODULO 2

Nossa classe Negociacao possui atributos privados, pois não faz sentido alterarmos uma instância de Negociacao depois de criada. Vamos recapitular:

export class Negociacao {

    constructor(private _data: Date, private _quantidade: number, private _valor: number) {}

    get data() {

        return this._data;
    }

    get quantidade() {

        return this._quantidade;
    }

    get valor() {

        return this._valor;
    }

    get volume() {

        return this._quantidade * this._valor;
    }
}

Contudo, o TypeScript possui um atalho para declaração de propriedades somente leitura. Para isso, basta usarmos o modificador readonly.

export class Negociacao {

    constructor(readonly data: Date, readonly quantidade: number, readonly valor: number) {}

    get volume() {

        return this.quantidade * this.valor;
    }
}
Veja que não foi necessário criar os getters para que pudéssemos acessar as propriedades que antes eram privadas. Agora, qualquer atribuição feita às propriedades resultarão em erro de compilação.

Esse código não compila. Parâmetros opcionais devem ser sempre os últimos parâmetros.
function (a?: number, b?:number, c:number): void { ... }
 
 Muitas vezes, atribuímos null e undefined à variáveis para realizarmos alguma espécie de controle. Mas esses tipos podem causar problemas em runtime em nosso código se não tivermos cuidado com eles:
 let nome: string = '';
nome = null; // algo permitido

Contudo, o TypeScript possui o modo strickNullChecks. Neste modo, null e undefined não fazem parte do domínio dos tipos e só podem ser atribuídos a eles mesmos. Com a exceção de undefined, que pode ser atribuído a void. Isso pode ser interessante para evitarmos valores nulos e indefinidos em nosso projeto.
Vamos ativá-lo em tsconfig.json:
{
    "compilerOptions": {
        "target": "es6",
        "outDir": "app/js",
        "noEmitOnError": true, 
        "noImplicitAny": true,
        "removeComments": true,
        "module": "system",
        "strictNullChecks": true
    },
    "include": [
        "app/ts/**/*"
    ]
}

Agora, nosso código deixará de compilar.
let nome: string = '';
// erro de compilação
nome = null;

// deixarmos explícitos que a função pode retornar boolean ou null
function minhaFuncao(flag: boolean): boolean | null {

    let valor = null;
    if(flag) return null;
    return true;
}

let x = minhaFuncao(false);
Agora, como explicitamos que seu retorno pode ser também null, nosso código passará pelo strictNullChecks. Curiosamente, linguagens como a Golang permitem uma função ou método ter mais de um tipo de retorno.

TypeScript possui um tipo curioso, o tipo never. Este tipo é aplicável à métodos ou funções que por algum motivo, planejado ou não, podem não terminar sua execução de seu bloco.
Exemplos clássicos são os de métodos que caem em um loop infinito ou de métodos que sempre retornam exceções. Exceções fazem com que o método não execute até o fim.
Não confundir o tipo never com o tipo void. O segundo, apesar de indicar que a função ou método nada retorna, indica que a função ou método executará até o fim, mesmo que não retorne nada.
Geralmente não usamos esse tipo em nosso código, mas ele pode aparecer como aviso do compilador. Quando aparecer, você já saberá que a execução do seu método nunca chegará até o fim, sendo um forte indicativo de um bug em seu código.


Vamos alterar nosso código para não permitir que negociações feitas no sábado ou no domingo sejam cadastradas.

// app-src/controllers/NegociacaoController.ts

    adiciona(event: Event) {
        ...
        let data = new Date(this._inputData.val().replace(/-/g, ','));

        if(data.getDay() == 0 || data.getDay() == 6) {

            this._mensagemView.update('Somente negociações em dias úteis, por favor!');
            return 
        }
        ...
    }
No entanto, ver em nosso código algo como ==0 e ==6 não nos diz muita coisa. Poderíamos até ter criado uma variável como sabado ou domingo, contudo o TypeScript possui um recurso mais elegante para o problema que estamos vendo, as enumerations.

Dentro do mesmo arquivo que definimos nosso controller, vamos criar a enum DiaDaSemana:

enum DiaDaSemana {
    Domingo,
    Segunda,
    Terca,
    Quarta, 
    Quinta, 
    Sexta, 
    Sabado, 
}

// exemplo
enum Tipo {

    ESPECIAL,
    PADRAO
}

Sabemos que o valor de Tipo.ESPECIAL e Tipo.PADRAO serão 0 e 1 respectivamente.

Agora, em nosso código fazemos:

let tipo: Tipo = Tipo.ESPECIAL;
É uma sintaxe totalmente válida. E agora?

let tipo: Tipo = 4;
O código anterior compila? Compila! Se você vem de outra linguagem como Java ou C#, este código não compilaria, porque só poderíamos utilizar os tipos Tipo.ESPECIAL e Tipo.PADRAO.

A questão é que a enum tem como subtipo number, por isso pode receber qualquer outro número que não esteja dentro do escopo da Enum.

Aprendemos neste capítulo:

Definir propriedades readonly
Parâmetros opcionais
Habilitar strictNullCheck
O uso de Enum
=========================
MODULO 3

Podemos isolar a lógica do nosso teste de performance em um único lugar e aplicá-lo nos métodos que temos interesse sem que tenhamos que modificar sua implementação. Para tal, precisamos ativar em nosso compilador TypeScript a configuração experimentalDecorators. Quando true, permite utilizar decorators, estrutura que atenderá nossa finalidade.

Como criar um decorator? Vamos criar o arquivo app/ts/helpers/decorators/logarTempoDeExecucao.ts e nele exportamos uma função de mesmo nome:

export function logarTempoDeExecucao() {
    ...
}

Agora, importando e utilizando em View

import { logarTempoDeExecucao } from '../helpers/decorators/index';

export abstract class View<T> {
    ...
    @logarTempoDeExecucao()
    update(model: T) {
        ...
    }
}

Usamos decorator através de um @, seguido do nome do decorator, abrindo e fechando parênteses no final, justo, porque um decorator nada mais é do que uma função.

Recarregando nossa aplicação tudo continua funcionando. Agora precisamos escrever a lógica do teste de performance em nosso decorator.

Nossa aplicação é funcional, mas podemos organizar ainda melhor nosso código. Percebam que no constructor() de NegociacaoController procuramos os elementos do DOM para que possamos extrair seus valores ao adicionarmos uma negociação. Essa busca é feita assim que nossa classe é instanciada. Mas se o usuário abre a aplicação e desiste de adicionar negociações? Nós teríamos varrido o DOM desnecessariamente. Além disso, se nossa aplicação crescer e tiver que interagir com mais elementos, já estaríamos buscando todos de uma vez. Podemos melhorar isso com auxílio de decorators de propriedades.

Antes de criarmos nosso decorator, queremos algo assim:

import { NegociacoesView, MensagemView } from '../views/index';
import { Negociacoes, Negociacao } from '../models/index';

export class NegociacaoController {

@domInject('#data')
private _inputData: JQuery;

@domInject('#quantidade')
private _inputQuantidade: JQuery;

@domInject('#valor')
private _inputValor: JQuery;
....
}

Nosso código não compila, claro, mas a ideia é injetarmos os elementos do DOM diretamente na propriedade da classe. Além disso, usaremos a estratégia de lazy loading. Por debaixo dos panos, vamos substituir cada propriedade por um getter. Sendo um getter, podemos escrever um bloco de código que ainda assim para o JavaScript ele será considerado uma propriedade. Nesse bloco de código, só buscaremos o elemento do DOM quando o getter for acessado pela primeira vez. Novos acessos retornarão o mesmo elemento!

// app/ts/helpers/decorators/domInject.ts 

export function domInject(seletor: string) {

    return function(target: any, key: string) {

        let elemento: JQuery;

        const getter = function() {

            if(!elemento) {
                console.log(`buscando  ${seletor} para injetar em ${key}`);
                elemento = $(seletor);
            }

            return elemento;
        }
    }
}

Aprendemos neste capítulo:

Isolar requisitos funcionais através de decorators
Decorators de métodos
Decorators de propriedades
A estratégia de lazy loading
=========================
